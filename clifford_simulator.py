"""
A simple simulator for Clifford circuits using Pauli-string stabilizers.

- State is represented by a list of stabilizer generators, each as a Pauli
  string over {I, X, Y, Z} on n qubits.
- Initial state is |0...0>, whose stabilizer group is generated by {Z_i}.

We update stabilizers by **conjugation rules** for each gate:
  g : P ↦ g P g†

We ignore global phases, so we only track the Pauli letters, not ± or ±i.
"""

import clifford


class CliffordSimulator:
    def __init__(self):
        self.instructions = []
        self.num_qubits = 0
        # List of stabilizer generators, each a string of length num_qubits
        self.stabilizers = []

    # ------------------------------------------------------------
    # Program management
    # ------------------------------------------------------------

    def load_program(self, instructions):
        """Load a Clifford program (list of clifford.QRegDecl / CliffordInstruction)."""
        self.instructions = list(instructions)

    def add_instruction(self, instr):
        self.instructions.append(instr)

    # ------------------------------------------------------------
    # Internal helpers
    # ------------------------------------------------------------

    @staticmethod
    def _pauli_to_bits(p: str):
        """
        Map Pauli letter to (x,z) bits:

            I -> (0,0)
            X -> (1,0)
            Z -> (0,1)
            Y -> (1,1)   (≈ i XZ)
        """
        if p == "I":
            return (0, 0)
        if p == "X":
            return (1, 0)
        if p == "Z":
            return (0, 1)
        if p == "Y":
            return (1, 1)
        raise ValueError(f"Unknown Pauli letter {p!r}")

    @staticmethod
    def _bits_to_pauli(x: int, z: int):
        """Inverse of _pauli_to_bits, ignoring phase."""
        x = x & 1
        z = z & 1
        if x == 0 and z == 0:
            return "I"
        if x == 1 and z == 0:
            return "X"
        if x == 0 and z == 1:
            return "Z"
        if x == 1 and z == 1:
            return "Y"
        raise ValueError(f"Invalid bits (x={x}, z={z})")

    def _init_stabilizers_for_qreg(self, n: int):
        """
        Initialize stabilizers for |0...0> (n qubits):

            Generators: Z_0, Z_1, ..., Z_{n-1}
        """
        self.num_qubits = n
        self.stabilizers = []
        for i in range(n):
            s = ["I"] * n
            s[i] = "Z"
            self.stabilizers.append("".join(s))

    # ------------------------------------------------------------
    # Gate conjugation rules on stabilizers
    # ------------------------------------------------------------

    def _conjugate_single_qubit(self, gate: str, qubit: int):
        """
        Conjugate all stabilizer generators by a single-qubit Clifford gate on 'qubit':

            g P g†

        Gates: H, S, X, Y, Z.
        """
        new_stabs = []

        for s in self.stabilizers:
            s_list = list(s)
            p = s_list[qubit]
            x, z = self._pauli_to_bits(p)

            if gate == "H":
                # H: X ↔ Z,   Y -> -Y (ignore sign)
                # In (x,z) form: (x,z) -> (z,x)
                x, z = z, x

            elif gate == "S":
                # S: X -> Y, Y -> X, Z->Z (ignoring signs)
                # In (x,z): (x,z) -> (x, x ⊕ z)
                x, z = x, (x ^ z)

            elif gate in {"X", "Y", "Z"}:
                # Conjugation by a Pauli only introduces a phase (±),
                # which we ignore in this simplified stabilizer tracking.
                # So (x,z) is unchanged.
                pass

            else:
                raise ValueError(f"Unsupported single-qubit gate {gate!r}")

            s_list[qubit] = self._bits_to_pauli(x, z)
            new_stabs.append("".join(s_list))

        self.stabilizers = new_stabs

    def _conjugate_cnot(self, control: int, target: int):
        """
        Conjugate all stabilizer generators by CNOT(control, target).

        Using the standard symplectic action on Pauli exponents:

            Let P = (X^a Z^b)_c ⊗ (X^c Z^d)_t.

            Under CNOT(c,t):
                x_c' = a'
                z_c' = b'
                x_t' = c'
                z_t' = d'

            with:
                a' = a
                b' = b ⊕ d
                c' = a ⊕ c
                d' = d

        We convert each Pauli letter at control/target into (x,z), update, and convert back.
        """
        new_stabs = []

        for s in self.stabilizers:
            s_list = list(s)

            # control
            p_c = s_list[control]
            x_c, z_c = self._pauli_to_bits(p_c)

            # target
            p_t = s_list[target]
            x_t, z_t = self._pauli_to_bits(p_t)

            # Apply CNOT conjugation
            a, b, c, d = x_c, z_c, x_t, z_t

            a_prime = a
            b_prime = b ^ d
            c_prime = a ^ c
            d_prime = d

            # Map back to Pauli letters
            s_list[control] = self._bits_to_pauli(a_prime, b_prime)
            s_list[target] = self._bits_to_pauli(c_prime, d_prime)

            new_stabs.append("".join(s_list))

        self.stabilizers = new_stabs

    # ------------------------------------------------------------
    # Execution
    # ------------------------------------------------------------

    def run(self):
        """
        Execute the loaded Clifford program.

        Supported:
          - QRegDecl: qreg q[N];
          - CNOT
          - H, S, X, Y, Z  (Clifford generators and Paulis)
        """
        for instr in self.instructions:
            if isinstance(instr, clifford.QRegDecl):
                self._handle_qreg_decl(instr)
            elif isinstance(instr, clifford.CliffordInstruction):
                self._handle_clifford_gate(instr)
            else:
                print(f"[WARN] Unsupported instruction in Clifford simulator: {instr}")

    def _handle_qreg_decl(self, decl: clifford.QRegDecl):
        print(f"[CliffordSim] Allocate qreg {decl.reg_name}[{decl.size}]")
        self._init_stabilizers_for_qreg(decl.size)

    def _handle_clifford_gate(self, instr: clifford.CliffordInstruction):
        name = instr.name
        qubits = instr.qubits

        if name == "CNOT":
            if len(qubits) != 2:
                raise ValueError("CNOT must have exactly 2 qubits")
            c = qubits[0].index
            t = qubits[1].index
            print(f"[CliffordSim] Apply CNOT on ({c}, {t})")
            self._conjugate_cnot(c, t)

        elif name in {"H", "S", "X", "Y", "Z"}:
            if len(qubits) != 1:
                raise ValueError(f"{name} gate must have exactly 1 qubit")
            q = qubits[0].index
            print(f"[CliffordSim] Apply {name} on {q}")
            self._conjugate_single_qubit(name, q)

        else:
            raise ValueError(f"Unsupported Clifford gate: {name!r}")

    # ------------------------------------------------------------
    # Introspection
    # ------------------------------------------------------------

    def print_stabilizers(self):
        print("Final stabilizer generators:")
        for s in self.stabilizers:
            print("  ", s)


# ---------------------------------------------------------------------
# Example usage (smoke test)
# ---------------------------------------------------------------------

if __name__ == "__main__":
    # Example Clifford circuit:
    #   qreg q[2];
    #   H q[0];
    #   CNOT q[0], q[1];
    prog = [
        clifford.QRegDecl("q", 2),
        clifford.SingleQubitGate("H", clifford.CliffordQubitRef("q", 0)),
        clifford.CNOT(
            clifford.CliffordQubitRef("q", 0),
            clifford.CliffordQubitRef("q", 1),
        ),
    ]

    sim = CliffordSimulator()
    sim.load_program(prog)
    sim.run()
    sim.print_stabilizers()
